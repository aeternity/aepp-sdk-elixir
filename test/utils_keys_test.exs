defmodule UtilsKeysTest do
  use ExUnit.Case

  doctest AeppSDK.Utils.Keys,
    except: [generate_keypair: 0, read_keypair: 3, read_keystore: 2, new_keystore: 3]

  alias AeppSDK.Utils.Keys

  @keys_path "./keys"
  @keystore_name "keystore.json"

  setup_all do
    js_cli_keypair = %{
      public: "ak_eCuh2MyVXxAVZddjmJhEv2oSu1Z7AQfHbf7CHb5J8CyqSNS7N",
      secret:
        "4886693515ada9acf24df75cb6b07c6515d9746446bcd6b3b90cbd5f220cb738547aae90e8660a70228eabcf666ad71123a44b45664d0b91c0566613914b0c8d"
    }

    # test a keypair generated by the JS cli and one generated by the Keys module
    keys1 = bundle_keys(js_cli_keypair)
    keys2 = bundle_keys(Keys.generate_keypair())

    on_exit(fn ->
      File.rm_rf!(@keys_path)
      File.rm_rf!(@keystore_name)
    end)

    [
      {:bundled_keys, [keys1, keys2]}
    ]
  end

  test "save and read keys", setup_data do
    Enum.each(setup_data.bundled_keys, fn keys ->
      assert :ok == Keys.save_keypair(keys.keypair, "password123", @keys_path, "keypair1")
      assert {:ok, keys.keypair} == Keys.read_keypair("password123", @keys_path, "keypair1")

      # non-existent keys
      assert match?({:error, _reason}, Keys.read_keypair("password123", @keys_path, "keypair123"))

      # invalid file name
      assert match?(
               {:error, _reason},
               Keys.save_keypair(keys.keypair, "password123", @keys_path, "")
             )
    end)
  end

  test "signing", setup_data do
    Enum.each(setup_data.bundled_keys, fn keys ->
      signature = Keys.sign("message123", keys.secret_key_binary)
      assert {:ok, "message123"} == Keys.verify(signature, "message123", keys.public_key_binary)
    end)
  end

  test "encoding", setup_data do
    Enum.each(setup_data.bundled_keys, fn keys ->
      assert keys.public == Keys.public_key_from_binary(keys.public_key_binary)
      assert keys.secret == Keys.secret_key_from_binary(keys.secret_key_binary)
    end)
  end

  test "keystore create, read", _setup_data do
    %{secret: secret_key} = Keys.generate_keypair()
    keystore_password = "12345a"
    assert :ok = Keys.new_keystore(secret_key, keystore_password, name: @keystore_name)
    path_to_the_file = Path.join(File.cwd!(), @keystore_name)
    assert true = File.exists?(path_to_the_file)
    assert secret_key === Keys.read_keystore(path_to_the_file, keystore_password)
  end

  defp bundle_keys(%{public: public_key, secret: secret_key} = keypair) do
    public_key_binary = Keys.public_key_to_binary(public_key)
    secret_key_binary = Keys.secret_key_to_binary(secret_key)

    %{
      keypair: keypair,
      public: public_key,
      public_key_binary: public_key_binary,
      secret: secret_key,
      secret_key_binary: secret_key_binary
    }
  end
end
